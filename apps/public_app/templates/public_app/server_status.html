{% extends "global_base.html" %}
{% load static %}

{% block title %}Server Status - SciTeX Cloud{% endblock %}

{% block meta_description %}
Check the current status of SciTeX Cloud services and infrastructure.
{% endblock %}

{% block extra_css %}
<style>
.server-status-container {
    max-width: 1400px;
    margin: 0 auto;
    padding: 4rem 2rem;
}

.status-hero {
    text-align: center;
    margin-bottom: 3rem;
}

.status-hero-title {
    font-size: 2.5rem;
    font-weight: 700;
    margin-bottom: 1rem;
    color: var(--text-primary);
}

.status-hero-subtitle {
    font-size: 1.1rem;
    color: var(--text-muted);
    max-width: 600px;
    margin: 0 auto;
}

.status-section {
    margin-bottom: 3rem;
}

.section-title {
    font-size: 1.5rem;
    font-weight: 600;
    margin-bottom: 1.5rem;
    color: var(--text-primary);
    display: flex;
    align-items: center;
    gap: 0.75rem;
}

.section-title i {
    color: var(--scitex-color-04);
}

.services-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 1.5rem;
}

.service-card {
    background: var(--bg-surface);
    border: 2px solid var(--border-default);
    border-radius: 12px;
    padding: 1.5rem;
    transition: all 0.3s ease;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
}

.service-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 16px rgba(0, 0, 0, 0.16);
}

.service-card.running, .service-card.healthy {
    border-color: var(--status-success);
    background: linear-gradient(135deg, var(--bg-surface) 0%, rgba(76, 175, 80, 0.12) 100%);
}

.service-card.down, .service-card.unhealthy {
    border-color: var(--status-error);
    background: linear-gradient(135deg, var(--bg-surface) 0%, rgba(244, 67, 54, 0.12) 100%);
}

.service-card.warning, .service-card.starting {
    border-color: var(--status-warning);
    background: linear-gradient(135deg, var(--bg-surface) 0%, rgba(255, 152, 0, 0.12) 100%);
}

.service-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 1rem;
}

.service-name {
    font-size: 1.1rem;
    font-weight: 600;
    color: var(--text-primary);
}

.status-badge {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.25rem 0.75rem;
    border-radius: 20px;
    font-size: 0.85rem;
    font-weight: 500;
}

.status-badge.running, .status-badge.healthy {
    background: var(--status-success);
    color: white;
}

.status-badge.down, .status-badge.unhealthy {
    background: var(--status-error);
    color: white;
}

.status-badge.error, .status-badge.starting {
    background: var(--status-warning);
    color: white;
}

.status-badge i {
    font-size: 0.75rem;
}

.service-details {
    font-size: 0.9rem;
    color: var(--text-muted);
}

.service-details div {
    margin: 0.5rem 0;
}

.metric-card {
    background: linear-gradient(135deg, var(--bg-surface) 0%, rgba(54, 162, 235, 0.08) 100%);
    border: 1px solid var(--border-default);
    border-radius: 12px;
    padding: 1.5rem;
    text-align: center;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.12);
    transition: all 0.3s ease;
}

.metric-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.18);
}

.metric-value {
    font-size: 2.5rem;
    font-weight: 700;
    color: var(--text-primary);
    margin-bottom: 0.5rem;
}

.metric-label {
    font-size: 0.9rem;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.progress-bar {
    height: 8px;
    background: var(--border-default);
    border-radius: 4px;
    overflow: hidden;
    margin-top: 1rem;
}

.progress-fill {
    height: 100%;
    background: var(--status-success);
    transition: width 0.3s ease;
}

.progress-fill.warning {
    background: var(--status-warning);
}

.progress-fill.critical {
    background: var(--status-error);
}

.info-box {
    background: var(--color-attention-subtle);
    border-left: 3px solid var(--scitex-color-04);
    border-radius: 6px;
    padding: 1rem 1.5rem;
    margin-top: 2rem;
}

.info-box p {
    margin: 0;
    color: var(--text-primary);
}

.info-box a {
    color: var(--scitex-color-04);
    text-decoration: none;
    font-weight: 500;
}

.info-box a:hover {
    text-decoration: underline;
}

.info-card {
    background: linear-gradient(135deg, var(--bg-surface) 0%, rgba(5, 150, 105, 0.08) 100%);
    border: 1px solid var(--border-default);
    border-radius: 12px;
    padding: 1.5rem;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
    transition: all 0.3s ease;
}

.info-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.14);
}

/* Tooltip styles */
.has-tooltip {
    position: relative;
    cursor: help;
}

.has-tooltip:hover::after {
    content: attr(data-tooltip);
    position: absolute;
    left: 50%;
    bottom: calc(100% + 10px);
    transform: translateX(-50%);
    padding: 0.75rem 1rem;
    background: #2d3748;
    color: #fff;
    border-radius: 8px;
    font-size: 0.85rem;
    font-weight: normal;
    line-height: 1.5;
    white-space: normal;
    width: max-content;
    max-width: 320px;
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
    z-index: 10000;
    pointer-events: none;
}

.has-tooltip:hover::before {
    content: '';
    position: absolute;
    left: 50%;
    bottom: calc(100% + 4px);
    transform: translateX(-50%);
    border: 6px solid transparent;
    border-top-color: #2d3748;
    z-index: 10001;
    pointer-events: none;
}
</style>
{% endblock %}

{% block extra_js %}
<!-- Chart.js for time-series graphs -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
{% endblock %}

{% block content %}
<div class="server-status-container">
    <!-- Hero Section -->
    <div class="status-hero">
        <h1 class="status-hero-title">
            <i class="fas fa-server"></i> Server Status
        </h1>
        <p class="status-hero-subtitle">
            Real-time monitoring of SciTeX Cloud infrastructure and services
        </p>

        <!-- Health Status Legend -->
        <div style="margin-top: 2rem; display: flex; justify-content: center; gap: 2rem; flex-wrap: wrap;">
            <div class="has-tooltip" data-tooltip="Green = Service is running and passes its health check (e.g., HTTP 200, database query succeeds, port is open)." style="display: flex; align-items: center; gap: 0.5rem;">
                <div style="width: 12px; height: 12px; border-radius: 50%; background: var(--status-success);"></div>
                <span style="font-size: 0.9rem; color: var(--text-muted);">
                    <strong>Healthy:</strong> Running normally
                </span>
            </div>
            <div class="has-tooltip" data-tooltip="Orange = Service is running but health check not yet passing (within start_period grace period)." style="display: flex; align-items: center; gap: 0.5rem;">
                <div style="width: 12px; height: 12px; border-radius: 50%; background: var(--status-warning);"></div>
                <span style="font-size: 0.9rem; color: var(--text-muted);">
                    <strong>Starting:</strong> Initializing
                </span>
            </div>
            <div class="has-tooltip" data-tooltip="Red = Service is stopped, crashed, or health check failing (e.g., HTTP 500, database unreachable, port closed)." style="display: flex; align-items: center; gap: 0.5rem;">
                <div style="width: 12px; height: 12px; border-radius: 50%; background: var(--status-error);"></div>
                <span style="font-size: 0.9rem; color: var(--text-muted);">
                    <strong>Unhealthy:</strong> Service down
                </span>
            </div>
        </div>
    </div>

    <!-- Unified System Metrics -->
    <div class="status-section">
        <h2 class="section-title has-tooltip" id="metricsTitle" data-tooltip="Real-time metrics from the entire host computer (all processes, not just SciTeX). Charts update every 2 seconds.">
            <i class="fas fa-chart-area"></i> System Metrics (Last 1 Hour)
        </h2>
        <div class="services-grid" style="grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));">
            <!-- CPU Chart -->
            <div class="metric-card">
                <div class="metric-label" style="margin-bottom: 1rem; display: flex; justify-content: space-between; align-items: center;">
                    <span>
                        <i class="fas fa-microchip" style="color: rgb(54, 162, 235);"></i> CPU Usage
                    </span>
                    <span id="cpuCurrentValue" style="font-size: 1.2rem; font-weight: bold; color: rgb(54, 162, 235);">--</span>
                </div>
                <canvas id="cpuChart" style="max-height: 200px;"></canvas>
                {% if status_data.system.cpu_cores %}
                <div style="margin-top: 0.5rem; font-size: 0.8rem; color: var(--text-muted); text-align: center;">
                    {{ status_data.system.cpu_cores }} cores ({{ status_data.system.cpu_cores_logical }} logical)
                    {% if status_data.system.cpu_name %}
                    <br>{{ status_data.system.cpu_name|truncatechars:50 }}
                    {% endif %}
                </div>
                {% endif %}
            </div>

            <!-- Memory Chart -->
            <div class="metric-card">
                <div class="metric-label" style="margin-bottom: 1rem; display: flex; justify-content: space-between; align-items: center;">
                    <span>
                        <i class="fas fa-memory" style="color: rgb(255, 99, 132);"></i> Memory Usage
                    </span>
                    <span id="memoryCurrentValue" style="font-size: 1.2rem; font-weight: bold; color: rgb(255, 99, 132);">--</span>
                </div>
                <canvas id="memoryChart" style="max-height: 200px;"></canvas>
                {% if status_data.system.memory_total_gb %}
                <div style="margin-top: 0.5rem; font-size: 0.8rem; color: var(--text-muted); text-align: center;">
                    {{ status_data.system.memory_available_gb }} GB / {{ status_data.system.memory_total_gb }} GB available
                </div>
                {% endif %}
            </div>

            <!-- Disk Chart -->
            <div class="metric-card">
                <div class="metric-label" style="margin-bottom: 1rem; display: flex; justify-content: space-between; align-items: center;">
                    <span>
                        <i class="fas fa-hdd" style="color: rgb(75, 192, 192);"></i> Disk Usage
                    </span>
                    <span id="diskCurrentValue" style="font-size: 1.2rem; font-weight: bold; color: rgb(75, 192, 192);">--</span>
                </div>
                <canvas id="diskChart" style="max-height: 200px;"></canvas>
                {% if status_data.disk.total_tb %}
                <div style="margin-top: 0.5rem; font-size: 0.8rem; color: var(--text-muted); text-align: center;">
                    {{ status_data.disk.used_tb }} TB / {{ status_data.disk.total_tb }} TB used
                </div>
                {% endif %}
            </div>

            <!-- GPU Chart -->
            <div class="metric-card">
                <div class="metric-label" style="margin-bottom: 1rem; display: flex; justify-content: space-between; align-items: center;">
                    <span>
                        <i class="fas fa-desktop" style="color: rgb(153, 102, 255);"></i> GPU Usage
                    </span>
                    <span id="gpuCurrentValue" style="font-size: 1.2rem; font-weight: bold; color: rgb(153, 102, 255);">--</span>
                </div>
                <canvas id="gpuChart" style="max-height: 200px;"></canvas>
                <div id="gpuStatus" style="margin-top: 0.5rem; font-size: 0.8rem; color: var(--text-muted); text-align: center;">
                    <i class="fas fa-circle-notch fa-spin"></i> Detecting GPU...
                </div>
            </div>

            <!-- Disk I/O Chart -->
            <div class="metric-card">
                <div class="metric-label" style="margin-bottom: 1rem; display: flex; justify-content: space-between; align-items: center;">
                    <span>
                        <i class="fas fa-exchange-alt" style="color: rgb(255, 159, 64);"></i> Disk I/O Rate
                    </span>
                    <span id="diskIoCurrentValue" style="font-size: 1.2rem; font-weight: bold; color: rgb(255, 159, 64);">--</span>
                </div>
                <canvas id="diskIoChart" style="max-height: 200px;"></canvas>
                {% if status_data.system.disk_read_mb %}
                <div style="margin-top: 0.5rem; font-size: 0.8rem; color: var(--text-muted); text-align: center;">
                    Total: ↓{{ status_data.system.disk_read_mb }} MB read, ↑{{ status_data.system.disk_write_mb }} MB written
                </div>
                {% endif %}
            </div>

            <!-- Network I/O Chart -->
            <div class="metric-card">
                <div class="metric-label" style="margin-bottom: 1rem; display: flex; justify-content: space-between; align-items: center;">
                    <span>
                        <i class="fas fa-network-wired" style="color: rgb(255, 205, 86);"></i> Network I/O Rate
                    </span>
                    <span id="netIoCurrentValue" style="font-size: 1.2rem; font-weight: bold; color: rgb(255, 205, 86);">--</span>
                </div>
                <canvas id="netIoChart" style="max-height: 200px;"></canvas>
                {% if status_data.system.net_sent_mb %}
                <div style="margin-top: 0.5rem; font-size: 0.8rem; color: var(--text-muted); text-align: center;">
                    Total: ↑{{ status_data.system.net_sent_mb }} MB sent, ↓{{ status_data.system.net_recv_mb }} MB received
                </div>
                {% endif %}
            </div>

            <!-- Visitor Pool Chart -->
            <div class="metric-card">
                <div class="metric-label" style="margin-bottom: 1rem; display: flex; justify-content: space-between; align-items: center;">
                    <span class="has-tooltip" data-tooltip="Shows how many visitor slots are currently allocated. When full, new anonymous users must wait for a slot to free up (sessions expire after 60 minutes).">
                        <i class="fas fa-users" style="color: rgb(201, 203, 207);"></i> Visitor Pool Status
                    </span>
                    <span id="visitorPoolCurrentValue" style="font-size: 1.2rem; font-weight: bold; color: rgb(201, 203, 207);">--</span>
                </div>
                <canvas id="visitorPoolChart" style="max-height: 200px;"></canvas>
                <div style="margin-top: 0.5rem; font-size: 0.8rem; color: var(--text-muted); text-align: center;">
                    Anonymous visitor sessions (1h lifetime each)
                </div>
            </div>

            <!-- Active Users Chart -->
            <div class="metric-card">
                <div class="metric-label" style="margin-bottom: 1rem; display: flex; justify-content: space-between; align-items: center;">
                    <span class="has-tooltip" data-tooltip="Registered users with active sessions (not visitors). Counted based on Django session activity within the last 15 minutes.">
                        <i class="fas fa-user-check" style="color: rgb(75, 192, 192);"></i> Active Users
                    </span>
                    <span id="activeUsersCurrentValue" style="font-size: 1.2rem; font-weight: bold; color: rgb(75, 192, 192);">--</span>
                </div>
                <canvas id="activeUsersChart" style="max-height: 200px;"></canvas>
                <div style="margin-top: 0.5rem; font-size: 0.8rem; color: var(--text-muted); text-align: center;">
                    Currently logged-in users with active sessions
                </div>
            </div>
        </div>
    </div>

    <!-- Docker Services -->
    <div class="status-section">
        <h2 class="section-title has-tooltip" data-tooltip="Containers managed by docker-compose. Health determined by Docker's built-in healthcheck commands (e.g., 'curl http://localhost:PORT/' for web services).">
            <i class="fab fa-docker"></i> Docker Services
        </h2>
        <div class="services-grid">
            {% for service in status_data.services %}
            <div class="service-card {{ service.health_class }} has-tooltip"
                 data-tooltip="Health Check: Docker healthcheck command verifies service is responding. {% if 'django' in service.name|lower %}curl http://localhost:8000/{% elif 'nginx' in service.name|lower %}curl http://localhost:80/{% elif 'postgres' in service.name|lower or 'db' in service.name|lower %}pg_isready command{% elif 'redis' in service.name|lower %}redis-cli ping{% elif 'gitea' in service.name|lower %}curl http://localhost:3000/{% elif 'flower' in service.name|lower %}curl http://localhost:5555/{% elif 'celery' in service.name|lower %}Python redis ping test{% elif 'cloudflared' in service.name|lower %}cloudflared version check{% endif %}">
                <div class="service-header">
                    <div class="service-name">
                        <i class="fas fa-cube"></i> {{ service.name|title }}
                    </div>
                    <span class="status-badge {{ service.health_class }}">
                        <i class="fas fa-circle"></i>
                        {% if service.health_status %}
                            {{ service.health_status|upper }}
                        {% else %}
                            {{ service.status|upper }}
                        {% endif %}
                    </span>
                </div>
                <div class="service-details">
                    {% if service.health_status and service.health_status != 'healthy' %}
                    <div><strong>Container:</strong> {{ service.status }}</div>
                    {% endif %}
                    {% if service.image %}
                    <div><strong>Image:</strong> {{ service.image }}</div>
                    {% endif %}
                    {% if service.error %}
                    <div style="color: var(--status-error);"><strong>Error:</strong> {{ service.error }}</div>
                    {% endif %}
                </div>
            </div>
            {% empty %}
            <div class="service-card warning">
                <p>No Docker services detected</p>
            </div>
            {% endfor %}
        </div>
    </div>

    <!-- SSH Services -->
    <div class="status-section">
        <h2 class="section-title has-tooltip" data-tooltip="SSH gateways for terminal access. Health checked by TCP socket connection test. All services use key-based authentication only (no passwords).">
            <i class="fas fa-key"></i> SSH Services
        </h2>
        <div class="services-grid">
            {% for ssh in status_data.ssh_services %}
            <div class="service-card {{ ssh.health_class }} has-tooltip"
                 data-tooltip="Health Check: TCP socket connection test to port {{ ssh.port }}. Returns healthy if port is open and accepting connections.">
                <div class="service-header">
                    <div class="service-name">
                        <i class="fas fa-terminal"></i> {{ ssh.name }}
                    </div>
                    <span class="status-badge {{ ssh.health_class }}">
                        <i class="fas fa-circle"></i>
                        {% if ssh.health_class == 'healthy' %}HEALTHY{% elif ssh.health_class == 'unhealthy' %}UNHEALTHY{% else %}{{ ssh.status|upper }}{% endif %}
                    </span>
                </div>
                <div class="service-details">
                    <div><strong>Port:</strong> {{ ssh.port }}</div>
                    <div><strong>Auth:</strong> SSH Key Only</div>
                    {% if ssh.error %}
                    <div style="color: var(--status-error);"><strong>Error:</strong> {{ ssh.error }}</div>
                    {% endif %}
                </div>
            </div>
            {% endfor %}
        </div>

        <!-- SSH Authentication Info -->
        <div class="info-box" style="margin-top: 1.5rem;">
            <p>
                <i class="fas fa-info-circle"></i>
                <strong>SSH Authentication:</strong> All SSH services use key-based authentication only.
                <a href="/accounts/settings/ssh-keys/">Manage your SSH keys →</a>
            </p>
        </div>
    </div>

    <!-- Database & Cache -->
    <div class="status-section">
        <h2 class="section-title has-tooltip" data-tooltip="PostgreSQL: Main database (health = 'SELECT 1' query succeeds). Redis: Session storage and cache (health = cache.set/get works).">
            <i class="fas fa-database"></i> Database & Cache
        </h2>
        <div class="services-grid">
            <!-- PostgreSQL -->
            <div class="service-card {{ status_data.database.health_class }} has-tooltip"
                 data-tooltip="Health Check: Executes 'SELECT 1' query. Returns healthy if database connection succeeds and query returns result.">
                <div class="service-header">
                    <div class="service-name">
                        <i class="fas fa-database"></i> PostgreSQL
                    </div>
                    <span class="status-badge {{ status_data.database.health_class }}">
                        <i class="fas fa-circle"></i>
                        {% if status_data.database.health_class == 'healthy' %}HEALTHY{% elif status_data.database.health_class == 'unhealthy' %}UNHEALTHY{% else %}{{ status_data.database.status|upper }}{% endif %}
                    </span>
                </div>
                <div class="service-details">
                    {% if status_data.database.backend %}
                    <div><strong>Backend:</strong> {{ status_data.database.backend }}</div>
                    {% endif %}
                    {% if status_data.database.name %}
                    <div><strong>Database:</strong> {{ status_data.database.name }}</div>
                    {% endif %}
                    {% if status_data.database.error %}
                    <div style="color: var(--status-error);"><strong>Error:</strong> {{ status_data.database.error }}</div>
                    {% endif %}
                </div>
            </div>

            <!-- Redis -->
            <div class="service-card {{ status_data.redis.health_class }} has-tooltip"
                 data-tooltip="Health Check: Performs cache.set() and cache.get() operations. Returns healthy if both operations succeed.">
                <div class="service-header">
                    <div class="service-name">
                        <i class="fas fa-memory"></i> Redis Cache
                    </div>
                    <span class="status-badge {{ status_data.redis.health_class }}">
                        <i class="fas fa-circle"></i>
                        {% if status_data.redis.health_class == 'healthy' %}HEALTHY{% elif status_data.redis.health_class == 'unhealthy' %}UNHEALTHY{% else %}{{ status_data.redis.status|upper }}{% endif %}
                    </span>
                </div>
                <div class="service-details">
                    <div><strong>Purpose:</strong> Session & Cache</div>
                    {% if status_data.redis.error %}
                    <div style="color: var(--status-error);"><strong>Error:</strong> {{ status_data.redis.error }}</div>
                    {% endif %}
                </div>
            </div>
        </div>
    </div>

    <!-- Computational Services (SLURM & Apptainer) -->
    <div class="status-section">
        <h2 class="section-title has-tooltip" data-tooltip="SLURM: Job scheduler and resource manager (health = 'sinfo' command returns partitions). Apptainer: Secure container runtime for user code execution (health = version command succeeds).">
            <i class="fas fa-server"></i> Computational Services
        </h2>
        <div class="services-grid">
            <!-- SLURM -->
            <div class="service-card {{ status_data.slurm.health_class }} has-tooltip"
                 data-tooltip="Health Check: Executes 'sinfo' command. Returns healthy if command succeeds and returns partition information.">
                <div class="service-header">
                    <div class="service-name">
                        <i class="fas fa-tasks"></i> Slurm
                    </div>
                    <span class="status-badge {{ status_data.slurm.health_class }}">
                        <i class="fas fa-circle"></i>
                        {% if status_data.slurm.health_class == 'healthy' %}HEALTHY{% elif status_data.slurm.health_class == 'unhealthy' %}DOWN{% else %}{{ status_data.slurm.status|upper }}{% endif %}
                    </span>
                </div>
                <div class="service-details">
                    <div><strong>Purpose:</strong> Job Scheduling & Resource Management</div>
                    {% if status_data.slurm.partitions %}
                    <div><strong>Partitions:</strong> {{ status_data.slurm.partitions }}</div>
                    {% endif %}
                    {% if status_data.slurm.error %}
                    <div style="color: var(--status-error);"><strong>Error:</strong> {{ status_data.slurm.error }}</div>
                    {% endif %}
                    {% if not status_data.slurm.is_running and not status_data.slurm.error %}
                    <div style="color: var(--status-warning);"><strong>Hint:</strong> Run <code>make slurm-start</code> to start</div>
                    {% endif %}
                </div>
            </div>

            <!-- Apptainer/Singularity -->
            <div class="service-card {{ status_data.apptainer.health_class }} has-tooltip"
                 data-tooltip="Health Check: Executes 'apptainer --version' command. Returns healthy if command succeeds and returns version string.">
                <div class="service-header">
                    <div class="service-name">
                        <i class="fas fa-box"></i> {{ status_data.apptainer.command|default:"Apptainer"|title }}
                    </div>
                    <span class="status-badge {{ status_data.apptainer.health_class }}">
                        <i class="fas fa-circle"></i>
                        {% if status_data.apptainer.health_class == 'healthy' %}HEALTHY{% elif status_data.apptainer.health_class == 'unhealthy' %}ERROR{% else %}{{ status_data.apptainer.status|upper }}{% endif %}
                    </span>
                </div>
                <div class="service-details">
                    <div><strong>Purpose:</strong> Secure Container Runtime</div>
                    {% if status_data.apptainer.version %}
                    <div><strong>Version:</strong> {{ status_data.apptainer.version }}</div>
                    {% endif %}
                    {% if status_data.apptainer.error %}
                    <div style="color: var(--status-error);"><strong>Error:</strong> {{ status_data.apptainer.error }}</div>
                    {% endif %}
                </div>
            </div>
        </div>

        <!-- HPC Info -->
        <div class="info-box" style="margin-top: 1.5rem;">
            <p>
                <i class="fas fa-info-circle"></i>
                <strong>HPC Terminal:</strong> User terminals run inside Apptainer containers via SLURM for security and resource management.
            </p>
        </div>
    </div>

    <!-- Visitor Pool Slots -->
    <div class="status-section">
        <h2 class="section-title has-tooltip" data-tooltip="Anonymous users get temporary visitor slots (visitor-001, visitor-002, etc.) with 60-minute sessions. Pool size configured via SCITEX_VISITOR_POOL_SIZE in .env file.">
            <i class="fas fa-users"></i> Visitor Pool Status
            {% if status_data.visitor_pool.pool_status %}
            <span style="font-size: 0.9rem; color: var(--text-muted); font-weight: normal; margin-left: 1rem;">
                {{ status_data.visitor_pool.pool_status.allocated }}/{{ status_data.visitor_pool.pool_status.total }} slots allocated
            </span>
            {% endif %}
        </h2>

        <style>
        .slots-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1.5rem;
            margin-top: 1.5rem;
        }

        .slot-card {
            background: var(--bg-surface);
            border: 2px solid var(--border-default);
            border-radius: 12px;
            padding: 1.5rem;
            position: relative;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            transition: all 0.3s ease;
        }

        .slot-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 14px rgba(0, 0, 0, 0.14);
        }

        .slot-card.allocated {
            border-color: var(--status-warning);
            background: linear-gradient(135deg, var(--bg-surface) 0%, rgba(255, 152, 0, 0.12) 100%);
        }

        .slot-card.free {
            border-color: var(--status-success);
            background: linear-gradient(135deg, var(--bg-surface) 0%, rgba(76, 175, 80, 0.10) 100%);
        }

        .slot-card.current-user {
            border-color: var(--workspace-icon-primary);
            border-width: 3px;
            background: linear-gradient(135deg, var(--bg-surface) 0%, rgba(5, 150, 105, 0.20) 100%);
            box-shadow: 0 6px 16px rgba(5, 150, 105, 0.35);
        }

        .slot-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .slot-number {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .slot-status-badge {
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .slot-status-badge.allocated {
            background: rgba(255, 152, 0, 0.2);
            color: #ff9800;
        }

        .slot-status-badge.free {
            background: rgba(76, 175, 80, 0.2);
            color: #4caf50;
        }

        .slot-info {
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        .slot-time-remaining {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.75rem;
            padding: 0.75rem;
            background: rgba(255, 152, 0, 0.1);
            border-radius: 8px;
        }

        .slot-time-remaining i {
            color: #ff9800;
        }
        </style>

        {% if status_data.visitor_pool.allocations %}
        <div class="slots-grid">
            {% for allocation in status_data.visitor_pool.allocations %}
            <div class="slot-card {{ allocation.status }} {% if allocation.is_current_user %}current-user{% endif %}">
                <div class="slot-header">
                    <div class="slot-number">
                        <i class="fas fa-cube" style="margin-right: 0.5rem; color: var(--workspace-icon-primary);"></i>
                        Slot #{{ allocation.slot_number }}
                    </div>
                    <span class="slot-status-badge {{ allocation.status }}">
                        {{ allocation.status|upper }}
                    </span>
                </div>

                {% if allocation.status == "allocated" %}
                <div class="slot-info">
                    <i class="fas fa-user" style="color: #ff9800; margin-right: 0.5rem;"></i>
                    {{ allocation.visitor_username }}{% if allocation.is_current_user %} <strong style="color: var(--workspace-icon-primary);">(You)</strong>{% endif %}
                </div>
                <div class="slot-time-remaining" data-expires="{{ allocation.expires_at|date:'c' }}">
                    <i class="fas fa-clock"></i>
                    <span>
                        Expires in {{ allocation.minutes_remaining }} min
                    </span>
                </div>
                {% else %}
                <div class="slot-info">
                    <i class="fas fa-check-circle" style="color: #4caf50; margin-right: 0.5rem;"></i>
                    Available
                </div>
                {% endif %}
            </div>
            {% endfor %}
        </div>
        {% else %}
        <div class="info-box" style="margin-top: 1.5rem;">
            <p>
                <i class="fas fa-exclamation-triangle"></i>
                Could not load visitor pool status.
            </p>
        </div>
        {% endif %}

        <!-- How It Works -->
        <div style="margin-top: 3rem;">
            <h3 style="font-size: 1.5rem; margin-bottom: 1.5rem; color: var(--text-primary);">
                <i class="fas fa-info-circle"></i> How Visitor Mode Works
            </h3>

            <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 1.5rem;">
                <!-- Slot Allocation -->
                <div class="info-card">
                    <h4 style="font-size: 1.2rem; margin-bottom: 0.75rem; color: var(--text-primary);">
                        <i class="fas fa-user-tag" style="color: var(--workspace-icon-primary);"></i>
                        Slot Allocation
                    </h4>
                    <p style="color: var(--text-muted); font-size: 0.95rem; line-height: 1.6; margin: 0;">
                        Navigate to any workspace to get assigned a visitor slot (e.g., <code>visitor-001</code>). First-come, first-served.
                    </p>
                </div>

                <!-- Data Separation -->
                <div class="info-card">
                    <h4 style="font-size: 1.2rem; margin-bottom: 0.75rem; color: var(--text-primary);">
                        <i class="fas fa-shield-alt" style="color: var(--workspace-icon-primary);"></i>
                        Data Privacy
                    </h4>
                    <p style="color: var(--text-muted); font-size: 0.95rem; line-height: 1.6; margin: 0;">
                        Your data is completely isolated. Each visitor has a private workspace. No one else can see your work.
                    </p>
                </div>

                <!-- Session Duration -->
                <div class="info-card">
                    <h4 style="font-size: 1.2rem; margin-bottom: 0.75rem; color: var(--text-primary);">
                        <i class="fas fa-clock" style="color: var(--workspace-icon-primary);"></i>
                        60-Minute Sessions
                    </h4>
                    <p style="color: var(--text-muted); font-size: 0.95rem; line-height: 1.6; margin: 0;">
                        Slots expire after 1 hour. Sign up to migrate your data and get unlimited access.
                    </p>
                </div>

                <!-- Sign Up -->
                <div class="info-card">
                    <h4 style="font-size: 1.2rem; margin-bottom: 0.75rem; color: var(--text-primary);">
                        <i class="fas fa-user-plus" style="color: var(--workspace-icon-primary);"></i>
                        Keep Your Work
                    </h4>
                    <p style="color: var(--text-muted); font-size: 0.95rem; line-height: 1.6; margin: 0;">
                        <a href="{% url 'auth_app:signup' %}" style="color: var(--workspace-icon-primary);">Sign up</a> anytime to save your work permanently. All data auto-migrates.
                    </p>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
// Real-time metrics charts with Chart.js
// Wait for Chart.js to load
window.addEventListener('load', function() {
(function() {
    const MAX_DATA_POINTS = 1800; // Keep up to 1 hour of data (at ~2 sec intervals = 1800 points)
    const UPDATE_INTERVAL = 2000; // Update every 2 seconds

    // Chart configuration for percentage metrics (CPU, Memory, Disk, GPU)
    const percentChartConfig = {
        type: 'line',
        options: {
            responsive: true,
            maintainAspectRatio: true,
            animation: {
                duration: 300
            },
            interaction: {
                intersect: false,
                mode: 'index'
            },
            scales: {
                x: {
                    type: 'time',
                    time: {
                        unit: 'minute',
                        stepSize: 5,
                        displayFormats: {
                            minute: 'HH:mm',
                            second: 'HH:mm:ss'
                        },
                        tooltipFormat: 'HH:mm:ss'
                    },
                    title: {
                        display: true,
                        text: 'Time',
                        font: {
                            size: 12,
                            weight: 'bold'
                        }
                    },
                    ticks: {
                        maxRotation: 0,
                        autoSkipPadding: 15,
                        maxTicksLimit: 12
                    },
                    grid: {
                        display: true,
                        color: 'rgba(0, 0, 0, 0.05)'
                    }
                },
                y: {
                    beginAtZero: true,
                    max: 100,
                    title: {
                        display: true,
                        text: 'Usage (%)',
                        font: {
                            size: 12,
                            weight: 'bold'
                        }
                    },
                    ticks: {
                        callback: function(value) {
                            return value + '%';
                        }
                    },
                    grid: {
                        display: true,
                        color: 'rgba(0, 0, 0, 0.05)'
                    }
                }
            },
            plugins: {
                legend: {
                    display: false
                },
                tooltip: {
                    enabled: true,
                    callbacks: {
                        label: function(context) {
                            return context.parsed.y !== null ? context.parsed.y.toFixed(1) + '%' : 'N/A';
                        }
                    }
                }
            }
        }
    };

    // Chart configuration for I/O metrics (MB/s rates)
    const ioChartConfig = {
        type: 'line',
        options: {
            responsive: true,
            maintainAspectRatio: true,
            animation: {
                duration: 300
            },
            interaction: {
                intersect: false,
                mode: 'index'
            },
            scales: {
                x: {
                    type: 'time',
                    time: {
                        unit: 'minute',
                        stepSize: 5,
                        displayFormats: {
                            minute: 'HH:mm',
                            second: 'HH:mm:ss'
                        },
                        tooltipFormat: 'HH:mm:ss'
                    },
                    title: {
                        display: true,
                        text: 'Time',
                        font: {
                            size: 12,
                            weight: 'bold'
                        }
                    },
                    ticks: {
                        maxRotation: 0,
                        autoSkipPadding: 15,
                        maxTicksLimit: 12
                    },
                    grid: {
                        display: true,
                        color: 'rgba(0, 0, 0, 0.05)'
                    }
                },
                y: {
                    beginAtZero: true,
                    title: {
                        display: true,
                        text: 'Rate (MB/s)',
                        font: {
                            size: 12,
                            weight: 'bold'
                        }
                    },
                    ticks: {
                        callback: function(value) {
                            return value.toFixed(2) + ' MB/s';
                        }
                    },
                    grid: {
                        display: true,
                        color: 'rgba(0, 0, 0, 0.05)'
                    }
                }
            },
            plugins: {
                legend: {
                    display: true,
                    position: 'top'
                },
                tooltip: {
                    enabled: true,
                    callbacks: {
                        label: function(context) {
                            return context.dataset.label + ': ' + (context.parsed.y !== null ? context.parsed.y.toFixed(3) + ' MB/s' : 'N/A');
                        }
                    }
                }
            }
        }
    };

    // Initialize CPU chart
    const cpuCtx = document.getElementById('cpuChart').getContext('2d');
    const cpuChart = new Chart(cpuCtx, {
        ...percentChartConfig,
        data: {
            datasets: [{
                label: 'CPU Usage',
                data: [],
                borderColor: 'rgb(54, 162, 235)',
                backgroundColor: 'rgba(54, 162, 235, 0.15)',
                borderWidth: 3,
                tension: 0.3,
                fill: true,
                spanGaps: false,  // Don't connect points when there are null values
                pointRadius: 0,
                pointHitRadius: 10,
                pointHoverRadius: 4,
                pointHoverBackgroundColor: 'rgb(54, 162, 235)',
                pointHoverBorderColor: '#fff',
                pointHoverBorderWidth: 2
            }]
        }
    });

    // Initialize Memory chart
    const memoryCtx = document.getElementById('memoryChart').getContext('2d');
    const memoryChart = new Chart(memoryCtx, {
        ...percentChartConfig,
        data: {
            datasets: [{
                label: 'Memory Usage',
                data: [],
                borderColor: 'rgb(255, 99, 132)',
                backgroundColor: 'rgba(255, 99, 132, 0.15)',
                borderWidth: 3,
                tension: 0.3,
                fill: true,
                spanGaps: false,  // Don't connect points when there are null values
                pointRadius: 0,
                pointHitRadius: 10,
                pointHoverRadius: 4,
                pointHoverBackgroundColor: 'rgb(255, 99, 132)',
                pointHoverBorderColor: '#fff',
                pointHoverBorderWidth: 2
            }]
        }
    });

    // Initialize Disk chart
    const diskCtx = document.getElementById('diskChart').getContext('2d');
    const diskChart = new Chart(diskCtx, {
        ...percentChartConfig,
        data: {
            datasets: [{
                label: 'Disk Usage',
                data: [],
                borderColor: 'rgb(75, 192, 192)',
                backgroundColor: 'rgba(75, 192, 192, 0.15)',
                borderWidth: 3,
                tension: 0.3,
                fill: true,
                spanGaps: false,  // Don't connect points when there are null values
                pointRadius: 0,
                pointHitRadius: 10,
                pointHoverRadius: 4,
                pointHoverBackgroundColor: 'rgb(75, 192, 192)',
                pointHoverBorderColor: '#fff',
                pointHoverBorderWidth: 2
            }]
        }
    });

    // Initialize GPU chart
    const gpuCtx = document.getElementById('gpuChart').getContext('2d');
    const gpuChart = new Chart(gpuCtx, {
        ...percentChartConfig,
        data: {
            datasets: [{
                label: 'GPU Usage',
                data: [],
                borderColor: 'rgb(153, 102, 255)',
                backgroundColor: 'rgba(153, 102, 255, 0.15)',
                borderWidth: 3,
                tension: 0.3,
                fill: true,
                spanGaps: false,  // Don't connect points when there are null values
                pointRadius: 0,
                pointHitRadius: 10,
                pointHoverRadius: 4,
                pointHoverBackgroundColor: 'rgb(153, 102, 255)',
                pointHoverBorderColor: '#fff',
                pointHoverBorderWidth: 2
            }]
        }
    });

    // Initialize Disk I/O chart
    const diskIoCtx = document.getElementById('diskIoChart').getContext('2d');
    const diskIoChart = new Chart(diskIoCtx, {
        ...ioChartConfig,
        data: {
            datasets: [
                {
                    label: 'Read',
                    data: [],
                    borderColor: 'rgb(75, 192, 192)',
                    backgroundColor: 'rgba(75, 192, 192, 0.15)',
                    borderWidth: 2,
                    tension: 0.3,
                    fill: false,
                    pointRadius: 0,
                    pointHitRadius: 10,
                    pointHoverRadius: 4
                },
                {
                    label: 'Write',
                    data: [],
                    borderColor: 'rgb(255, 159, 64)',
                    backgroundColor: 'rgba(255, 159, 64, 0.15)',
                    borderWidth: 2,
                    tension: 0.3,
                    fill: false,
                    pointRadius: 0,
                    pointHitRadius: 10,
                    pointHoverRadius: 4
                }
            ]
        }
    });

    // Initialize Network I/O chart
    const netIoCtx = document.getElementById('netIoChart').getContext('2d');
    const netIoChart = new Chart(netIoCtx, {
        ...ioChartConfig,
        data: {
            datasets: [
                {
                    label: 'Sent',
                    data: [],
                    borderColor: 'rgb(255, 99, 132)',
                    backgroundColor: 'rgba(255, 99, 132, 0.15)',
                    borderWidth: 2,
                    tension: 0.3,
                    fill: false,
                    pointRadius: 0,
                    pointHitRadius: 10,
                    pointHoverRadius: 4
                },
                {
                    label: 'Received',
                    data: [],
                    borderColor: 'rgb(54, 162, 235)',
                    backgroundColor: 'rgba(54, 162, 235, 0.15)',
                    borderWidth: 2,
                    tension: 0.3,
                    fill: false,
                    pointRadius: 0,
                    pointHitRadius: 10,
                    pointHoverRadius: 4
                }
            ]
        }
    });

    // Initialize Visitor Pool chart
    const visitorPoolCtx = document.getElementById('visitorPoolChart').getContext('2d');
    const visitorPoolChart = new Chart(visitorPoolCtx, {
        ...percentChartConfig,
        data: {
            datasets: [{
                label: 'Allocated Slots',
                data: [],
                borderColor: 'rgb(201, 203, 207)',
                backgroundColor: 'rgba(201, 203, 207, 0.15)',
                borderWidth: 3,
                tension: 0.3,
                fill: true,
                spanGaps: false,
                pointRadius: 0,
                pointHitRadius: 10,
                pointHoverRadius: 4,
                pointHoverBackgroundColor: 'rgb(201, 203, 207)',
                pointHoverBorderColor: '#fff',
                pointHoverBorderWidth: 2
            }]
        },
        options: {
            ...percentChartConfig.options,
            scales: {
                ...percentChartConfig.options.scales,
                y: {
                    ...percentChartConfig.options.scales.y,
                    max: 4,  // Pool size is 4
                    title: {
                        display: true,
                        text: 'Allocated Slots',
                        font: {
                            size: 12,
                            weight: 'bold'
                        }
                    },
                    ticks: {
                        stepSize: 1,
                        callback: function(value) {
                            return value;  // Show as integer
                        }
                    }
                }
            }
        }
    });

    // Initialize Active Users chart
    const activeUsersCtx = document.getElementById('activeUsersChart').getContext('2d');
    const activeUsersChart = new Chart(activeUsersCtx, {
        ...percentChartConfig,
        data: {
            datasets: [{
                label: 'Active Users',
                data: [],
                borderColor: 'rgb(75, 192, 192)',
                backgroundColor: 'rgba(75, 192, 192, 0.15)',
                borderWidth: 3,
                tension: 0.3,
                fill: true,
                spanGaps: false,
                pointRadius: 0,
                pointHitRadius: 10,
                pointHoverRadius: 4,
                pointHoverBackgroundColor: 'rgb(75, 192, 192)',
                pointHoverBorderColor: '#fff',
                pointHoverBorderWidth: 2
            }]
        },
        options: {
            ...percentChartConfig.options,
            scales: {
                ...percentChartConfig.options.scales,
                y: {
                    ...percentChartConfig.options.scales.y,
                    title: {
                        display: true,
                        text: 'Number of Users',
                        font: {
                            size: 12,
                            weight: 'bold'
                        }
                    },
                    ticks: {
                        stepSize: 1,
                        callback: function(value) {
                            return Math.floor(value);  // Show as integer
                        }
                    }
                }
            }
        }
    });

    let gpuAvailable = null;  // Track GPU availability
    let lastDiskRead = null;  // Track previous disk read for rate calculation
    let lastDiskWrite = null; // Track previous disk write for rate calculation
    let lastNetSent = null;   // Track previous net sent for rate calculation
    let lastNetRecv = null;   // Track previous net recv for rate calculation
    let lastTimestamp = null; // Track previous timestamp for rate calculation

    // Helper function to format time range text
    function formatTimeRangeText(hours) {
        if (hours === 1) return 'Last 1 Hour';
        if (hours < 24) return `Last ${hours} Hours`;
        if (hours === 24) return 'Last 24 Hours';
        if (hours === 168) return 'Last 7 Days';
        if (hours === 720) return 'Last 30 Days';
        const days = Math.floor(hours / 24);
        return `Last ${days} Days`;
    }

    // Load historical data on page load
    async function loadHistoricalData(hours = 1) {
        try {
            // Calculate appropriate limit based on hours (assuming 5-second intervals)
            // 1 hour = 720 points, 6 hours = 4320 points, 24 hours = 17280 points
            const limit = Math.min(hours * 720, 20000);  // Cap at 20k points for performance

            const response = await fetch(`/api/server-metrics/history/?hours=${hours}&limit=${limit}`);
            const data = await response.json();

            if (data.metrics && data.metrics.length > 0) {
                // Clear existing chart data
                cpuChart.data.datasets[0].data = [];
                memoryChart.data.datasets[0].data = [];
                diskChart.data.datasets[0].data = [];
                gpuChart.data.datasets[0].data = [];
                diskIoChart.data.datasets[0].data = [];
                diskIoChart.data.datasets[1].data = [];
                netIoChart.data.datasets[0].data = [];
                netIoChart.data.datasets[1].data = [];
                visitorPoolChart.data.datasets[0].data = [];
                activeUsersChart.data.datasets[0].data = [];

                // Populate charts with historical data (use NaN for not-recorded data)
                let prevMetric = null;
                data.metrics.forEach((metric, index) => {
                    const timestamp = metric.timestamp;

                    // CPU data - use NaN for missing values
                    cpuChart.data.datasets[0].data.push({
                        x: timestamp,
                        y: (metric.cpu_percent !== null && metric.cpu_percent !== undefined && !isNaN(metric.cpu_percent))
                            ? metric.cpu_percent : NaN
                    });

                    // Memory data - use NaN for missing values
                    memoryChart.data.datasets[0].data.push({
                        x: timestamp,
                        y: (metric.memory_percent !== null && metric.memory_percent !== undefined && !isNaN(metric.memory_percent))
                            ? metric.memory_percent : NaN
                    });

                    // Disk data - use NaN for missing values
                    diskChart.data.datasets[0].data.push({
                        x: timestamp,
                        y: (metric.disk_percent !== null && metric.disk_percent !== undefined && !isNaN(metric.disk_percent))
                            ? metric.disk_percent : NaN
                    });

                    // GPU data - use NaN for missing values
                    gpuChart.data.datasets[0].data.push({
                        x: timestamp,
                        y: (metric.gpu_percent !== null && metric.gpu_percent !== undefined && !isNaN(metric.gpu_percent))
                            ? metric.gpu_percent : NaN
                    });

                    // Visitor pool data - use NaN for missing values
                    visitorPoolChart.data.datasets[0].data.push({
                        x: timestamp,
                        y: (metric.visitor_pool_allocated !== null && metric.visitor_pool_allocated !== undefined && !isNaN(metric.visitor_pool_allocated))
                            ? metric.visitor_pool_allocated : NaN
                    });

                    // Active users data - use NaN for missing values
                    activeUsersChart.data.datasets[0].data.push({
                        x: timestamp,
                        y: (metric.active_users_count !== null && metric.active_users_count !== undefined && !isNaN(metric.active_users_count))
                            ? metric.active_users_count : NaN
                    });

                    // Calculate I/O rates (skip first point)
                    if (prevMetric && index > 0) {
                        const timeDiff = (timestamp - prevMetric.timestamp) / 1000; // seconds

                        // Disk I/O rates (MB/s)
                        if (metric.disk_read_mb !== null && prevMetric.disk_read_mb !== null) {
                            const diskReadRate = (metric.disk_read_mb - prevMetric.disk_read_mb) / timeDiff;
                            const diskWriteRate = (metric.disk_write_mb - prevMetric.disk_write_mb) / timeDiff;

                            diskIoChart.data.datasets[0].data.push({ x: timestamp, y: Math.max(0, diskReadRate) });
                            diskIoChart.data.datasets[1].data.push({ x: timestamp, y: Math.max(0, diskWriteRate) });
                        }

                        // Network I/O rates (MB/s)
                        if (metric.net_sent_mb !== null && prevMetric.net_sent_mb !== null) {
                            const netSentRate = (metric.net_sent_mb - prevMetric.net_sent_mb) / timeDiff;
                            const netRecvRate = (metric.net_recv_mb - prevMetric.net_recv_mb) / timeDiff;

                            netIoChart.data.datasets[0].data.push({ x: timestamp, y: Math.max(0, netSentRate) });
                            netIoChart.data.datasets[1].data.push({ x: timestamp, y: Math.max(0, netRecvRate) });
                        }
                    }

                    prevMetric = metric;
                });

                // Store last values for real-time rate calculation
                if (data.metrics.length > 0) {
                    const lastMetric = data.metrics[data.metrics.length - 1];
                    lastDiskRead = lastMetric.disk_read_mb;
                    lastDiskWrite = lastMetric.disk_write_mb;
                    lastNetSent = lastMetric.net_sent_mb;
                    lastNetRecv = lastMetric.net_recv_mb;
                    lastTimestamp = lastMetric.timestamp;
                }

                // Adjust time scale based on data range
                const timeUnit = hours <= 1 ? 'minute' : hours <= 6 ? 'minute' : hours <= 24 ? 'hour' : hours <= 168 ? 'hour' : 'day';
                const stepSize = hours <= 1 ? 5 : hours <= 6 ? 30 : hours <= 24 ? 2 : hours <= 168 ? 6 : 1;
                const displayFormat = hours <= 6 ? 'HH:mm' : hours <= 168 ? 'MMM D HH:mm' : 'MMM D';

                // Update all charts with adjusted time scale
                [cpuChart, memoryChart, diskChart, gpuChart, diskIoChart, netIoChart, visitorPoolChart, activeUsersChart].forEach(chart => {
                    chart.options.scales.x.time.unit = timeUnit;
                    chart.options.scales.x.time.stepSize = stepSize;
                    chart.options.scales.x.time.displayFormats[timeUnit] = displayFormat;
                    chart.update();
                });

                console.log(`Loaded ${data.metrics.length} data points (${formatTimeRangeText(hours)})`);
            } else {
                // No data available for this time range
                console.warn(`No historical data available for ${formatTimeRangeText(hours)}`);

                // Still update the time scale for consistency
                const timeUnit = hours <= 1 ? 'minute' : hours <= 6 ? 'minute' : hours <= 24 ? 'hour' : hours <= 168 ? 'hour' : 'day';
                const stepSize = hours <= 1 ? 5 : hours <= 6 ? 30 : hours <= 24 ? 2 : hours <= 168 ? 6 : 1;
                const displayFormat = hours <= 6 ? 'HH:mm' : hours <= 168 ? 'MMM D HH:mm' : 'MMM D';

                [cpuChart, memoryChart, diskChart, gpuChart, diskIoChart, netIoChart, visitorPoolChart, activeUsersChart].forEach(chart => {
                    chart.options.scales.x.time.unit = timeUnit;
                    chart.options.scales.x.time.stepSize = stepSize;
                    chart.options.scales.x.time.displayFormats[timeUnit] = displayFormat;
                    chart.update();
                });
            }
        } catch (error) {
            console.error('Error loading historical data:', error);
        }
    }

    // Fetch and update metrics
    async function updateMetrics() {
        try {
            const response = await fetch('/api/server-status/');
            const data = await response.json();

            const timestamp = data.timestamp;

            // Update CPU chart (use NaN for not-recorded data)
            const cpuValue = (data.cpu_percent !== null && data.cpu_percent !== undefined && !isNaN(data.cpu_percent))
                ? data.cpu_percent : NaN;
            cpuChart.data.datasets[0].data.push({
                x: timestamp,
                y: cpuValue
            });
            if (cpuChart.data.datasets[0].data.length > MAX_DATA_POINTS) {
                cpuChart.data.datasets[0].data.shift();
            }
            cpuChart.update('none'); // 'none' mode for better performance

            // Update current value display
            document.getElementById('cpuCurrentValue').textContent = !isNaN(cpuValue) ? cpuValue.toFixed(1) + '%' : 'N/A';

            // Update Memory chart (use NaN for not-recorded data)
            const memoryValue = (data.memory_percent !== null && data.memory_percent !== undefined && !isNaN(data.memory_percent))
                ? data.memory_percent : NaN;
            memoryChart.data.datasets[0].data.push({
                x: timestamp,
                y: memoryValue
            });
            if (memoryChart.data.datasets[0].data.length > MAX_DATA_POINTS) {
                memoryChart.data.datasets[0].data.shift();
            }
            memoryChart.update('none');

            // Update current value display
            document.getElementById('memoryCurrentValue').textContent = !isNaN(memoryValue) ? memoryValue.toFixed(1) + '%' : 'N/A';

            // Update Disk chart (use NaN for not-recorded data)
            const diskValue = (data.disk_percent !== null && data.disk_percent !== undefined && !isNaN(data.disk_percent))
                ? data.disk_percent : NaN;
            diskChart.data.datasets[0].data.push({
                x: timestamp,
                y: diskValue
            });
            if (diskChart.data.datasets[0].data.length > MAX_DATA_POINTS) {
                diskChart.data.datasets[0].data.shift();
            }
            diskChart.update('none');

            // Update current value display
            document.getElementById('diskCurrentValue').textContent = !isNaN(diskValue) ? diskValue.toFixed(1) + '%' : 'N/A';

            // Update GPU chart and status (use NaN for not-recorded data)
            const gpuStatusEl = document.getElementById('gpuStatus');
            const gpuValue = (data.gpu_percent !== null && data.gpu_percent !== undefined && !isNaN(data.gpu_percent))
                ? data.gpu_percent : NaN;

            if (!isNaN(gpuValue)) {
                // GPU is available
                if (gpuAvailable === null) {
                    gpuAvailable = true;
                    gpuStatusEl.innerHTML = '<i class="fas fa-check-circle" style="color: var(--status-success);"></i> GPU detected';
                }

                gpuChart.data.datasets[0].data.push({
                    x: timestamp,
                    y: gpuValue
                });
                if (gpuChart.data.datasets[0].data.length > MAX_DATA_POINTS) {
                    gpuChart.data.datasets[0].data.shift();
                }
                gpuChart.update('none');

                // Update current value display
                document.getElementById('gpuCurrentValue').textContent = gpuValue.toFixed(1) + '%';
            } else {
                // GPU is not available
                if (gpuAvailable === null) {
                    gpuAvailable = false;
                    gpuStatusEl.innerHTML = '<i class="fas fa-times-circle" style="color: var(--text-muted);"></i> No GPU available';
                }

                // Add NaN data point to maintain time continuity but don't display
                gpuChart.data.datasets[0].data.push({
                    x: timestamp,
                    y: NaN
                });
                if (gpuChart.data.datasets[0].data.length > MAX_DATA_POINTS) {
                    gpuChart.data.datasets[0].data.shift();
                }
                gpuChart.update('none');

                // Update current value display
                document.getElementById('gpuCurrentValue').textContent = 'N/A';
            }

            // Calculate and update Disk I/O rates
            if (lastDiskRead !== null && data.disk_read_mb_total !== undefined) {
                const timeDiff = lastTimestamp !== null ? (timestamp - lastTimestamp) / 1000 : 2; // seconds

                const diskReadRate = (data.disk_read_mb_total - lastDiskRead) / timeDiff;
                const diskWriteRate = (data.disk_write_mb_total - lastDiskWrite) / timeDiff;

                diskIoChart.data.datasets[0].data.push({ x: timestamp, y: Math.max(0, diskReadRate) });
                diskIoChart.data.datasets[1].data.push({ x: timestamp, y: Math.max(0, diskWriteRate) });

                if (diskIoChart.data.datasets[0].data.length > MAX_DATA_POINTS) {
                    diskIoChart.data.datasets[0].data.shift();
                    diskIoChart.data.datasets[1].data.shift();
                }
                diskIoChart.update('none');

                // Update current value display
                const totalIoRate = Math.max(0, diskReadRate) + Math.max(0, diskWriteRate);
                document.getElementById('diskIoCurrentValue').textContent = totalIoRate.toFixed(2) + ' MB/s';
            }

            // Calculate and update Network I/O rates
            if (lastNetSent !== null && data.net_sent_mb_total !== undefined) {
                const timeDiff = lastTimestamp !== null ? (timestamp - lastTimestamp) / 1000 : 2; // seconds

                const netSentRate = (data.net_sent_mb_total - lastNetSent) / timeDiff;
                const netRecvRate = (data.net_recv_mb_total - lastNetRecv) / timeDiff;

                netIoChart.data.datasets[0].data.push({ x: timestamp, y: Math.max(0, netSentRate) });
                netIoChart.data.datasets[1].data.push({ x: timestamp, y: Math.max(0, netRecvRate) });

                if (netIoChart.data.datasets[0].data.length > MAX_DATA_POINTS) {
                    netIoChart.data.datasets[0].data.shift();
                    netIoChart.data.datasets[1].data.shift();
                }
                netIoChart.update('none');

                // Update current value display
                const totalNetRate = Math.max(0, netSentRate) + Math.max(0, netRecvRate);
                document.getElementById('netIoCurrentValue').textContent = totalNetRate.toFixed(2) + ' MB/s';
            }

            // Update Visitor Pool chart (use NaN for not-recorded data)
            const visitorPoolValue = (data.visitor_pool_allocated !== null &&
                                      data.visitor_pool_allocated !== undefined &&
                                      !isNaN(data.visitor_pool_allocated))
                ? data.visitor_pool_allocated : NaN;

            visitorPoolChart.data.datasets[0].data.push({
                x: timestamp,
                y: visitorPoolValue
            });
            if (visitorPoolChart.data.datasets[0].data.length > MAX_DATA_POINTS) {
                visitorPoolChart.data.datasets[0].data.shift();
            }
            visitorPoolChart.update('none');

            // Update current value display
            if (!isNaN(visitorPoolValue) && data.visitor_pool_total !== null &&
                data.visitor_pool_total !== undefined) {
                document.getElementById('visitorPoolCurrentValue').textContent =
                    `${data.visitor_pool_allocated}/${data.visitor_pool_total}`;
            } else {
                document.getElementById('visitorPoolCurrentValue').textContent = 'N/A';
            }

            // Update Active Users chart (use NaN for not-recorded data)
            const activeUsersValue = (data.active_users_count !== null &&
                                      data.active_users_count !== undefined &&
                                      !isNaN(data.active_users_count))
                ? data.active_users_count : NaN;

            activeUsersChart.data.datasets[0].data.push({
                x: timestamp,
                y: activeUsersValue
            });
            if (activeUsersChart.data.datasets[0].data.length > MAX_DATA_POINTS) {
                activeUsersChart.data.datasets[0].data.shift();
            }
            activeUsersChart.update('none');

            // Update current value display
            if (!isNaN(activeUsersValue)) {
                document.getElementById('activeUsersCurrentValue').textContent = activeUsersValue;
            } else {
                document.getElementById('activeUsersCurrentValue').textContent = 'N/A';
            }

            // Update last values for next rate calculation
            lastDiskRead = data.disk_read_mb_total;
            lastDiskWrite = data.disk_write_mb_total;
            lastNetSent = data.net_sent_mb_total;
            lastNetRecv = data.net_recv_mb_total;
            lastTimestamp = timestamp;

        } catch (error) {
            console.error('Error fetching metrics:', error);
        }
    }

    // Load historical data first, then start real-time updates
    async function initialize() {
        await loadHistoricalData();  // Load 1 hour of historical data from database
        updateMetrics();              // Get first real-time update
        setInterval(updateMetrics, UPDATE_INTERVAL);  // Continue with periodic updates
    }

    initialize();
})();

}); // End of window.addEventListener('load')

// Live countdown timer for visitor pool slots
function updateVisitorCountdowns() {
    document.querySelectorAll('.slot-time-remaining').forEach(function(element) {
        const expiresAt = element.dataset.expires;
        if (!expiresAt) return;

        const span = element.querySelector('span');
        if (!span) return;

        // Calculate remaining time
        const now = new Date();
        const expires = new Date(expiresAt);
        const remainingMs = expires - now;
        const remainingSeconds = Math.max(0, Math.floor(remainingMs / 1000));
        const remainingMinutes = Math.floor(remainingSeconds / 60);

        // Update display
        if (remainingSeconds > 0) {
            span.textContent = `Expires in ${remainingMinutes} min`;
        } else {
            span.textContent = 'Expired';
            // Reload page to update status
            setTimeout(() => location.reload(), 1000);
        }
    });
}

// Update countdowns every second
setInterval(updateVisitorCountdowns, 1000);
updateVisitorCountdowns(); // Initial call
</script>

{% endblock %}
