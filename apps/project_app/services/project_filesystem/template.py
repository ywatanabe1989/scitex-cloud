"""
Project Template Management Module

Handles template initialization and customization for SciTeX projects.
This module provides functionality for:
- Creating minimal README files for empty projects
- Creating comprehensive README files for templated projects
- Generating project configuration files (YAML/JSON)
- Creating requirements.txt with scientific packages
- Initializing SciTeX Writer template structure

Extracted from ProjectFilesystemManager to improve modularity.
"""

import json
from pathlib import Path
from typing import Optional, Tuple

try:
    import yaml
    HAS_YAML = True
except ImportError:
    HAS_YAML = False

from ..models import Project


class ProjectTemplateManager:
    """Manages template creation and customization for projects."""

    def __init__(self, project_filesystem_manager):
        """
        Initialize template manager.

        Args:
            project_filesystem_manager: Parent ProjectFilesystemManager instance
        """
        self.manager = project_filesystem_manager
        self.user = project_filesystem_manager.user
        self.base_path = project_filesystem_manager.base_path

    def _create_minimal_readme(self, project: Project, project_path: Path):
        """Create minimal README file for empty projects."""
        readme_content = f"""# {project.name}

**Created:** {project.created_at.strftime("%Y-%m-%d")}
**Owner:** {project.owner.get_full_name() or project.owner.username}

## Description

{project.description or "No description provided."}

## Getting Started

This is an empty project directory. You can:

1. **Create from template** - Click the "Create from template" button to set up a full SciTeX research project structure
2. **Upload your files** - Upload your existing project files through the web interface
3. **Create manually** - Organize your project structure as you prefer

---
*Created with SciTeX Cloud*
"""

        readme_path = project_path / "README.md"
        with open(readme_path, "w", encoding="utf-8") as f:
            f.write(readme_content)

    def _create_project_readme(self, project: Project, project_path: Path):
        """Create README file for the project."""
        readme_content = f"""# {project.name}

**Created:** {project.created_at.strftime("%Y-%m-%d")}
**Owner:** {project.owner.get_full_name() or project.owner.username}
**Progress:** {getattr(project, "progress", 0)}%

## Description

{project.description or "No description provided."}

## Hypotheses

{getattr(project, "hypotheses", "No hypotheses defined.") or "No hypotheses defined."}

## Directory Structure

This project follows the standardized SciTeX research project structure:

- `config/` - Configuration files (YAML, JSON, etc.)
  - Project-specific configuration files
  - PATH configurations and environment settings
- `data/` - Research data and datasets
  - `raw/` - Original, unprocessed datasets
  - `processed/` - Cleaned and preprocessed data
  - `figures/` - Generated figures and visualizations
  - `models/` - Trained machine learning models
- `scripts/` - Source code and analysis scripts
  - Script-specific output directories with execution logs
  - Individual Python/R scripts for data processing and analysis
  - Execution tracking with RUNNING/FINISHED_SUCCESS markers
- `docs/` - Documentation and manuscripts
  - `manuscripts/` - Draft papers and publications
  - `notes/` - Research notes and documentation
  - `references/` - Citations and reference materials
- `results/` - Analysis outputs and reports
  - `outputs/` - Generated results and analysis outputs
  - `reports/` - Summary reports and findings
  - `analysis/` - Detailed analysis results
- `temp/` - Temporary and cache files
  - `cache/` - Cached computations and intermediate results
  - `logs/` - Execution logs and debugging information
  - `tmp/` - Temporary processing files

The structure supports:
- Symlinked data organization for efficient storage
- Script execution tracking with timestamped logs
- Reproducible research workflows
- Version control integration

## Getting Started

This project directory is managed by SciTeX Cloud. You can:

1. Upload files using the web interface
2. Edit documents in the Writer module
3. Run code in the Code module
4. Create visualizations in the Viz module
5. Manage references in the Scholar module

## Project Management

- Project ID: {project.id}
- Created: {project.created_at.strftime("%Y-%m-%d %H:%M:%S")}
- Last Updated: {project.updated_at.strftime("%Y-%m-%d %H:%M:%S")}

---
*This README was automatically generated by SciTeX Cloud*
"""

        readme_path = project_path / "README.md"
        with open(readme_path, "w", encoding="utf-8") as f:
            f.write(readme_content)

    def _create_project_config_files(self, project: Project, project_path: Path):
        """Create essential configuration files for the project."""
        config_path = project_path / "config"

        # Create project.yaml - main project configuration
        project_config = {
            "project": {
                "name": project.name,
                "id": project.id,
                "description": project.description,
                "created": project.created_at.isoformat(),
                "owner": project.owner.username,
                "progress": getattr(project, "progress", 0),
            },
            "paths": {
                "data_raw": "./data/raw",
                "data_processed": "./data/processed",
                "data_figures": "./data/figures",
                "data_models": "./data/models",
                "scripts": "./scripts",
                "results": "./results",
                "docs": "./docs",
                "temp": "./temp",
            },
            "execution": {
                "python_version": "3.8+",
                "requirements_file": "../requirements.txt",
                "log_level": "INFO",
                "cache_enabled": True,
            },
            "research": {
                "hypotheses": getattr(project, "hypotheses", "") or "",
                "keywords": [],
                "collaborators": [],
            },
        }

        if HAS_YAML:
            with open(config_path / "project.yaml", "w") as f:
                yaml.dump(project_config, f, default_flow_style=False, indent=2)
        else:
            # Fallback to JSON if YAML is not available
            with open(config_path / "project.json", "w") as f:
                json.dump(project_config, f, indent=2)

        # Create paths.json for script access
        paths_config = {
            "data": {
                "raw": str(project_path / "data" / "raw"),
                "processed": str(project_path / "data" / "processed"),
                "figures": str(project_path / "data" / "figures"),
                "models": str(project_path / "data" / "models"),
            },
            "scripts": str(project_path / "scripts"),
            "results": {
                "outputs": str(project_path / "results" / "outputs"),
                "reports": str(project_path / "results" / "reports"),
                "analysis": str(project_path / "results" / "analysis"),
            },
            "docs": str(project_path / "docs"),
            "temp": {
                "cache": str(project_path / "temp" / "cache"),
                "logs": str(project_path / "temp" / "logs"),
                "tmp": str(project_path / "temp" / "tmp"),
            },
        }

        with open(config_path / "paths.json", "w") as f:
            json.dump(paths_config, f, indent=2)

        # Create environment template
        env_template = f"""# SciTeX Project Environment Configuration
# Project: {project.name}

# Python Environment
PYTHON_PATH=./scripts
PYTHONPATH=${{PYTHONPATH}}:./scripts

# Data Paths
DATA_RAW=./data/raw
DATA_PROCESSED=./data/processed
DATA_FIGURES=./data/figures
DATA_MODELS=./data/models

# Output Paths
RESULTS_OUTPUT=./results/outputs
RESULTS_REPORTS=./results/reports
RESULTS_ANALYSIS=./results/analysis

# Temporary Paths
TEMP_CACHE=./temp/cache
TEMP_LOGS=./temp/logs
TEMP_TMP=./temp/tmp

# Project Settings
PROJECT_NAME="{project.name}"
PROJECT_ID={project.id}
LOG_LEVEL=INFO
CACHE_ENABLED=true

# Add your custom environment variables below
# API_KEY=your_api_key_here
# SCITEX_CLOUD_POSTGRES_URL=your_database_url_here
"""

        with open(config_path / ".env.template", "w") as f:
            f.write(env_template)

    def _create_requirements_file(self, project: Project, project_path: Path):
        """Create requirements.txt with essential scientific packages."""
        requirements = """# SciTeX Project Requirements
# Core scientific computing packages
numpy>=1.21.0
pandas>=1.3.0
matplotlib>=3.4.0
seaborn>=0.11.0
scipy>=1.7.0

# Data processing and analysis
scikit-learn>=1.0.0
statsmodels>=0.12.0

# Visualization
plotly>=5.0.0
bokeh>=2.4.0

# Jupyter and interactive computing
jupyter>=1.0.0
ipykernel>=6.0.0
nbformat>=5.1.0

# File I/O and data formats
openpyxl>=3.0.0
xlrd>=2.0.0
h5py>=3.1.0

# Development and testing
pytest>=6.2.0
black>=21.0.0
flake8>=3.9.0

# Documentation
sphinx>=4.0.0
sphinx-rtd-theme>=0.5.0

# Add your project-specific requirements below:
# tensorflow>=2.6.0
# torch>=1.9.0
# transformers>=4.9.0
"""

        with open(project_path / "requirements.txt", "w") as f:
            f.write(requirements)

    def initialize_scitex_writer_template(
        self, project: Project
    ) -> Tuple[bool, Optional[Path]]:
        """
        Initialize SciTeX Writer template structure for a project.

        Delegates to ensure_writer_directory from writer_app which uses
        scitex.writer.Writer() to properly initialize the complete workspace
        with all required directories, scripts, and configuration files.

        Args:
            project: Project instance

        Returns:
            Tuple of (success: bool, path: Optional[Path])
        """
        try:
            # Initialize Writer workspace using WriterService
            try:
                from apps.writer_app.services import WriterService
            except ImportError:
                import logging
                logger = logging.getLogger(__name__)
                logger.warning("WriterService not available - writer_app not installed")
                return False, None

            import logging
            logger = logging.getLogger(__name__)

            # Create WriterService - this initializes Writer() which creates the complete structure
            writer_service = WriterService(project.id, project.owner.id)

            # Access the writer property - this triggers initialization
            writer = writer_service.writer
            writer_path = writer_service.writer_dir

            if writer_path and writer_path.exists():
                logger.info(
                    f"âœ“ Writer template initialized successfully at: {writer_path}"
                )
                return True, writer_path
            else:
                logger.warning(
                    f"Writer initialization returned path but directory doesn't exist: {writer_path}"
                )
                return False, None

        except Exception as e:
            import logging
            logger = logging.getLogger(__name__)
            logger.error(
                f"Error initializing SciTeX Writer template: {e}", exc_info=True
            )

            # DO NOT accept incomplete writer directories as successful
            # Writer structure must be complete or it should fail entirely
            # This prevents partial initialization from being treated as success
            return False, None
