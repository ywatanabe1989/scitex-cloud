#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# File: /home/ywatanabe/proj/scitex-cloud/apps/scholar_app/views/search/search_helpers.py
# Auto-generated by refactoring script
# ----------------------------------------
from __future__ import annotations
import os

__FILE__ = "./apps/scholar_app/views/search/search_helpers.py"
__DIR__ = os.path.dirname(__FILE__)
# ----------------------------------------
from django.shortcuts import render
from django.http import JsonResponse
from django.views.decorators.http import require_http_methods
from django.contrib.auth.decorators import login_required
from django.views.decorators.csrf import csrf_exempt
from django.core.files.storage import default_storage
from django.core.cache import cache
from django.db.models import Q, Count, Avg, Max, Min
from django.utils import timezone
import json
import requests
import hashlib
from scitex import logging
import asyncio
from datetime import datetime, timedelta
from ...models import (
    SearchIndex, UserLibrary, Author, Journal,
    Collection, Topic, Annotation, AnnotationVote,
    CollaborationGroup, GroupMembership,
    AnnotationTag, UserPreference,
)
from apps.project_app.services import get_current_project

logger = logging.getLogger(__name__)

# Import scitex.scholar if available
try:
    from scitex.scholar.pipelines.ScholarPipelineSearchParallel import ScholarPipelineSearchParallel
    SCITEX_SCHOLAR_AVAILABLE = True
except ImportError:
    SCITEX_SCHOLAR_AVAILABLE = False


def extract_search_filters(request):
    """Extract all advanced search filters from request."""
    filters = {}

    # Year range filters
    year_from = request.GET.get("year_from")
    year_to = request.GET.get("year_to")
    if year_from:
        try:
            filters["year_from"] = int(year_from)
        except ValueError:
            pass
    if year_to:
        try:
            filters["year_to"] = int(year_to)
        except ValueError:
            pass

    # Citation count filter
    min_citations = request.GET.get("min_citations")
    if min_citations:
        try:
            filters["min_citations"] = int(min_citations)
        except ValueError:
            pass

    # Impact factor filter
    min_impact_factor = request.GET.get("min_impact_factor")
    if min_impact_factor:
        try:
            filters["min_impact_factor"] = float(min_impact_factor)
        except ValueError:
            pass

    # Author filter
    author = request.GET.get("author", "").strip()
    if author:
        # Split by comma and clean up
        authors = [a.strip() for a in author.split(",") if a.strip()]
        filters["authors"] = authors

    # Journal filter
    journal = request.GET.get("journal", "").strip()
    if journal:
        filters["journal"] = journal

    # Document type filter
    doc_type = request.GET.get("doc_type", "").strip()
    if doc_type:
        filters["doc_type"] = doc_type

    # Study type filter
    study_type = request.GET.get("study_type", "").strip()
    if study_type:
        filters["study_type"] = study_type

    # Language filter
    language = request.GET.get("language", "").strip()
    if language:
        filters["language"] = language

    # Quick filters
    if request.GET.get("open_access"):
        filters["open_access"] = True

    if request.GET.get("recent_only"):
        from datetime import datetime

        current_year = datetime.now().year
        filters["year_from"] = max(filters.get("year_from", 0), current_year - 5)

    if request.GET.get("high_impact"):
        filters["min_impact_factor"] = max(filters.get("min_impact_factor", 0), 5.0)

    return filters




def search_database_papers(query, filters):
    """Optimized database search with reduced complexity."""
    # Cache database results for better performance
    cache_key = (
        f"db_search_{hashlib.md5(f'{query}_{str(filters)}'.encode()).hexdigest()}"
    )
    cached_results = cache.get(cache_key)
    if cached_results is not None:
        return cached_results

    # Start with optimized text search - only essential fields
    queryset = (
        SearchIndex.objects.filter(title__icontains=query, status="active")
        .select_related("journal")
        .only(
            "id",
            "title",
            "abstract",
            "publication_date",
            "citation_count",
            "is_open_access",
            "pdf_url",
            "journal__name",
            "journal__impact_factor",
        )
    )

    # Apply only essential filters for performance
    if filters.get("year_from"):
        queryset = queryset.filter(publication_date__year__gte=filters["year_from"])
    if filters.get("year_to"):
        queryset = queryset.filter(publication_date__year__lte=filters["year_to"])

    if filters.get("min_citations"):
        queryset = queryset.filter(citation_count__gte=filters["min_citations"])

    if filters.get("open_access"):
        queryset = queryset.filter(is_open_access=True)

    # Simplified journal filter
    if filters.get("journal"):
        queryset = queryset.filter(journal__name__icontains=filters["journal"])

    # Skip complex author filtering for performance - can be added back if needed
    # Author search adds significant complexity and JOIN overhead

    # Limit results and cache for 30 minutes
    results = list(queryset.order_by("-relevance_score", "-citation_count")[:10])
    cache.set(cache_key, results, 1800)

    return results




def apply_advanced_filters(results, filters):
    """Apply advanced filters to search results."""
    if not filters:
        return results

    filtered_results = []

    for result in results:
        # Year range filter
        if filters.get("year_from") or filters.get("year_to"):
            try:
                year = int(result.get("year", 0))
                if filters.get("year_from") and year < filters["year_from"]:
                    continue
                if filters.get("year_to") and year > filters["year_to"]:
                    continue
            except (ValueError, TypeError):
                continue

        # Citation count filter
        if filters.get("min_citations"):
            try:
                citations = int(result.get("citations", 0))
                if citations < filters["min_citations"]:
                    continue
            except (ValueError, TypeError):
                continue

        # Impact factor filter
        if filters.get("min_impact_factor"):
            try:
                impact_factor = float(result.get("impact_factor", 0) or 0)
                if impact_factor < filters["min_impact_factor"]:
                    continue
            except (ValueError, TypeError):
                continue

        # Author filter
        if filters.get("authors"):
            authors_text = " ".join(result.get("authors", [])).lower()
            author_match = False
            for author_name in filters["authors"]:
                if author_name.lower() in authors_text:
                    author_match = True
                    break
            if not author_match:
                continue

        # Journal filter
        if filters.get("journal"):
            journal_name = result.get("journal", "").lower()
            if filters["journal"].lower() not in journal_name:
                continue

        # Open access filter
        if filters.get("open_access") and not result.get("is_open_access"):
            continue

        # Document type filter (basic implementation)
        if filters.get("doc_type"):
            # This would need to be enhanced with better document type detection
            title_and_abstract = (
                result.get("title", "") + " " + result.get("snippet", "")
            ).lower()
            doc_type = filters["doc_type"].lower()

            # Simple heuristic matching
            if doc_type == "review" and "review" not in title_and_abstract:
                continue
            elif (
                doc_type == "preprint"
                and "preprint" not in result.get("source", "").lower()
            ):
                continue

        # Language filter (basic implementation)
        if filters.get("language"):
            # Would need language detection for better implementation
            if filters["language"].lower() != "english":
                # For now, assume most papers are English unless specified
                continue

        filtered_results.append(result)

    return filtered_results




def get_paper_authors(paper):
    """Get formatted author string for a paper."""
    try:
        author_papers = paper.authors.through.objects.filter(paper=paper).order_by(
            "author_order"
        )[:3]  # Limit to 3 authors

        authors = []
        for ap in author_papers:
            author = ap.author
            if author.last_name and author.first_name:
                authors.append(f"{author.last_name}, {author.first_name[0]}.")
            elif author.last_name:
                authors.append(author.last_name)
            elif author.first_name:
                authors.append(author.first_name)

        return ", ".join(authors) if authors else "Unknown Authors"

    except Exception:
        return "Unknown Authors"



