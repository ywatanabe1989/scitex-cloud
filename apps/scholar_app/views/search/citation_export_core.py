#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# File: /home/ywatanabe/proj/scitex-cloud/apps/scholar_app/views/search/citation_export_core.py
# Auto-generated by refactoring script
# ----------------------------------------
from __future__ import annotations
import os

__FILE__ = "./apps/scholar_app/views/search/citation_export_core.py"
__DIR__ = os.path.dirname(__FILE__)
# ----------------------------------------
from django.shortcuts import render
from django.http import JsonResponse
from django.views.decorators.http import require_http_methods
from django.contrib.auth.decorators import login_required
from django.views.decorators.csrf import csrf_exempt
from django.core.files.storage import default_storage
from django.core.cache import cache
from django.db.models import Q, Count, Avg, Max, Min
from django.utils import timezone
import json
import requests
import hashlib
from scitex import logging
import asyncio
from datetime import datetime, timedelta
from ...models import (
    SearchIndex, UserLibrary, Author, Journal,
    Collection, Topic, Annotation, AnnotationVote,
    CollaborationGroup, GroupMembership,
    AnnotationTag, UserPreference,
)
from apps.project_app.services import get_current_project

logger = logging.getLogger(__name__)

# Import scitex.scholar if available
try:
    from scitex.scholar.pipelines.ScholarPipelineSearchParallel import ScholarPipelineSearchParallel
    SCITEX_SCHOLAR_AVAILABLE = True
except ImportError:
    SCITEX_SCHOLAR_AVAILABLE = False


# TODO: Implement citation export functionality
# These are placeholder stubs created to fix import errors
# Original implementation needs to be restored or re-implemented

@require_http_methods(["POST"])
@login_required
def export_citation(request):
    """Placeholder for export_citation - TODO: implement"""
    return JsonResponse({"error": "Not implemented"}, status=501)


def generate_citation(paper_data, format_type):
    """Generate citation in the specified format."""
    title = paper_data.get("title", "Unknown Title")
    authors = paper_data.get("authors", "Unknown Author")
    journal = paper_data.get("journal", "Unknown Journal")
    year = paper_data.get("year", "Unknown Year")
    doi = paper_data.get("doi", "")
    url = paper_data.get("url", "")
    volume = paper_data.get("volume", "")
    pages = paper_data.get("pages", "")
    pmid = paper_data.get("pmid", "")

    # Generate citation key from first author and year
    citation_key = generate_citation_key(authors, year)

    if format_type.lower() == "bibtex":
        return generate_bibtex(
            citation_key, title, authors, journal, year, doi, url, volume, pages, pmid
        )
    elif format_type.lower() == "endnote":
        return generate_endnote(
            title, authors, journal, year, doi, url, volume, pages, pmid
        )
    elif format_type.lower() == "ris":
        return generate_ris(
            title, authors, journal, year, doi, url, volume, pages, pmid
        )
    else:
        return None




def generate_citation_key(authors, year):
    """Generate a citation key from authors and year."""
    try:
        # Extract first author's last name
        if authors and isinstance(authors, str):
            first_author = authors.split(",")[0].split(" and ")[0].strip()
            # Remove common prefixes and suffixes
            first_author = first_author.replace("Dr.", "").replace("Prof.", "").strip()
            # Get last name (assume last word is last name)
            last_name = first_author.split()[-1] if first_author.split() else "Unknown"
            # Clean non-alphanumeric characters
            last_name = "".join(c for c in last_name if c.isalnum())
            return f"{last_name}{year}"
        return f"Unknown{year}"
    except (IndexError, AttributeError, TypeError, ValueError):
        # Failed to parse authors/year, use generic key
        return f"Paper{year}"




def generate_bibtex(
    citation_key, title, authors, journal, year, doi, url, volume, pages, pmid
):
    """Generate BibTeX citation."""
    bibtex = f"@article{{{citation_key},\n"
    bibtex += f"  title = {{{title}}},\n"
    bibtex += f"  author = {{{authors}}},\n"
    bibtex += f"  journal = {{{journal}}},\n"
    bibtex += f"  year = {{{year}}},\n"

    if volume:
        bibtex += f"  volume = {{{volume}}},\n"
    if pages:
        bibtex += f"  pages = {{{pages}}},\n"
    if doi:
        bibtex += f"  doi = {{{doi}}},\n"
    if url:
        bibtex += f"  url = {{{url}}},\n"
    if pmid:
        bibtex += f"  pmid = {{{pmid}}},\n"

    bibtex += "}"
    return bibtex




def generate_endnote(title, authors, journal, year, doi, url, volume, pages, pmid):
    """Generate EndNote citation."""
    endnote = "%0 Journal Article\n"
    endnote += f"%T {title}\n"
    endnote += f"%A {authors}\n"
    endnote += f"%J {journal}\n"
    endnote += f"%D {year}\n"

    if volume:
        endnote += f"%V {volume}\n"
    if pages:
        endnote += f"%P {pages}\n"
    if doi:
        endnote += f"%R {doi}\n"
    if url:
        endnote += f"%U {url}\n"
    if pmid:
        endnote += f"%M {pmid}\n"

    return endnote




def generate_ris(title, authors, journal, year, doi, url, volume, pages, pmid):
    """Generate RIS citation."""
    ris = "TY  - JOUR\n"
    ris += f"TI  - {title}\n"

    # Handle multiple authors
    if authors:
        author_list = authors.replace(" and ", ", ").split(", ")
        for author in author_list:
            ris += f"AU  - {author.strip()}\n"

    ris += f"JO  - {journal}\n"
    ris += f"PY  - {year}\n"

    if volume:
        ris += f"VL  - {volume}\n"
    if pages:
        ris += f"SP  - {pages}\n"
    if doi:
        ris += f"DO  - {doi}\n"
    if url:
        ris += f"UR  - {url}\n"
    if pmid:
        ris += f"ID  - {pmid}\n"

    ris += "ER  - \n"
    return ris




def sanitize_filename(filename):
    """Sanitize filename for safe download."""
    import re

    # Remove or replace invalid characters
    filename = re.sub(r'[<>:"/\\|?*]', "_", filename)
    # Limit length
    filename = filename[:50]
    # Remove extra spaces and replace with underscores
    filename = re.sub(r"\s+", "_", filename.strip())
    return filename




def get_file_extension(format_type):
    """Get file extension for citation format."""
    extensions = {"bibtex": "bib", "endnote": "enw", "ris": "ris"}
    return extensions.get(format_type.lower(), "txt")



